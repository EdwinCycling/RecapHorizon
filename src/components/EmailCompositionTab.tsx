import React, { useState, useEffect } from 'react';
import { useTranslation } from '../hooks/useTranslation';
import { FiMail, FiCopy, FiEye, FiSend, FiUsers, FiUser, FiEdit3, FiCheck, FiX } from 'react-icons/fi';
import EmailPreviewModal from './EmailPreviewModal';
import { GoogleGenAI } from '@google/genai';
import { getGeminiCode } from '../languages';
import { displayToast } from '../utils/clipboard';
import modelManager from '../utils/modelManager';
import BlurredLoadingOverlay from './BlurredLoadingOverlay';

interface EmailCompositionTabProps {
  transcript: string;
  summary: string;
  emailAddresses: string[];
  onPreviewEmail: (emailData: EmailData) => void;
  onOpenMailto: (emailData: EmailData) => void;
  // Added optional analysis inputs
  sentiment?: import('../../types').SentimentAnalysisResult | null;
  followup?: string;
  // User context for token validation
  userId: string;
  userTier: import('../../types').SubscriptionTier;
}

export interface EmailData {
  to: string[];
  cc: string[];
  bcc: string[];
  subject: string;
  title: string;
  body: string;
  format: 'plain' | 'html';
  tone: string;
  narrative: boolean;
  includeSummary: boolean;
  includeConclusion: boolean;
  includeActionPoints: boolean;
  detailLevel: 'very-short' | 'short' | 'medium' | 'extensive';
  replyIntent: string;
}

interface ExtractedEmail {
  email: string;
  type: 'to' | 'cc' | 'bcc' | 'none';
}

const EmailCompositionTab: React.FC<EmailCompositionTabProps> = ({
  transcript,
  summary,
  emailAddresses,
  onPreviewEmail,
  onOpenMailto,
  sentiment,
  followup,
  userId,
  userTier
}) => {
  const uiLang = (typeof window !== 'undefined' && window.localStorage.getItem('uiLang')) || 'en';
  const { t, currentLanguage } = useTranslation(uiLang as any);
  const [emailData, setEmailData] = useState<EmailData>({
      to: [],
      cc: [],
      bcc: [],
      subject: '',
      title: '',
      body: '',
      format: 'plain',
      tone: 'neutral',
      narrative: false,
      includeSummary: true,
      includeConclusion: false,
      includeActionPoints: false,
      detailLevel: 'medium',
      replyIntent: 'agree'
    });

  const [customSubject, setCustomSubject] = useState<string>('');
  const [customBody, setCustomBody] = useState<string>('');
  const [isCustomMode, setIsCustomMode] = useState<boolean>(false);
  const [extractedEmails, setExtractedEmails] = useState<ExtractedEmail[]>([]);
  const [autoGeneratedSubject, setAutoGeneratedSubject] = useState<string>('');
  const [aiHasGenerated, setAiHasGenerated] = useState<boolean>(false);

  // Extract email addresses from transcript and email source
  const extractEmailsFromTranscript = (text: string): string[] => {
    const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
    const matches = text.match(emailRegex) || [];
    return [...new Set(matches)]; // Remove duplicates
  };

  // Extract emails from email headers and content
  const extractEmailsFromEmailSource = (emailContent: string): string[] => {
    const emails: string[] = [];
    
    // Extract from headers (To, From, CC, BCC)
    const headerRegex = /^(To|From|CC|BCC|Cc|Bcc):\s*(.+)$/gm;
    let headerMatch;
    while ((headerMatch = headerRegex.exec(emailContent)) !== null) {
      const headerValue = headerMatch[2];
      const emailMatches = headerValue.match(/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}/g) || [];
      emails.push(...emailMatches);
    }
    
    // Extract from email body content
    const bodyEmailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
    const bodyMatches = emailContent.match(bodyEmailRegex) || [];
    emails.push(...bodyMatches);
    
    return [...new Set(emails)]; // Remove duplicates
  };

  // Generate auto subject from transcript/summary (AI one-sentence summary preference)
  const generateAutoSubject = (text: string): string => {
    const cleaned = (text || '')
      .replace(/^#+\s*/gm, '')
      .replace(/\*\*|__|[_*`~]/g, '')
      .replace(/\n+/g, ' ')
      .trim();
    const sentences = cleaned.split(/[.!?]+\s/).filter(s => s.trim().length > 10);
    if (sentences.length > 0) {
      const firstSentence = sentences[0].trim();
      return firstSentence.length > 80 ? firstSentence.substring(0, 77) + '...' : firstSentence;
    }
    return t('emailComposition.defaultSubject', 'Vergaderverslag');
  };

  // Initialize extracted emails and auto subject
  useEffect(() => {
    // Combine provided addresses with any found in transcript
    const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
    const fromTranscript = (transcript || '').match(emailRegex) || [];
    const unique = Array.from(new Set([...(emailAddresses || []), ...fromTranscript]));
    setExtractedEmails(unique.map(email => ({ email, type: 'none' })));
    
    const autoSubject = generateAutoSubject(summary || transcript);
    setAutoGeneratedSubject(autoSubject);
    
    if (!isCustomMode) {
      setEmailData(prev => ({ ...prev, subject: autoSubject, title: autoSubject }));
    }
  }, [emailAddresses, summary, transcript, isCustomMode]);

  // Compose email body from selected sections
  const buildEmailBody = (): string => {
    if (isCustomMode) return customBody;
    const parts: string[] = [];
    // Salutation starts the email body; do NOT duplicate the title/subject here
    parts.push(t('emailSalutation', 'Beste koersliefhebbers,'));
    // Summary
    if (emailData.includeSummary && (summary?.trim()?.length || 0) > 0) {
      parts.push('');
      parts.push(`${t('summary', 'Samenvatting')}:`);
      parts.push(summary.trim());
    }
    // Conclusion
    if (emailData.includeConclusion && sentiment?.conclusion && sentiment.conclusion.trim().length > 0) {
      parts.push('');
      parts.push(`${t('conclusions', 'Conclusies')}:`);
      parts.push(sentiment.conclusion.trim());
    }
    // Action Points
    if (emailData.includeActionPoints && followup && followup.trim().length > 0) {
      parts.push('');
      parts.push(`${t('actionPoints', 'Actiepunten')}:`);
      parts.push(followup.trim());
    }
    // Closing
    parts.push('');
    parts.push(t('emailClosing', 'Met sportieve groet,'));
    parts.push('Edwin');
    return parts.join('\n');
  };

  // Update email body when content or selections change
  useEffect(() => {
    const body = buildEmailBody();
    setEmailData(prev => ({ ...prev, body, format: 'plain' }));
    setAiHasGenerated(false);
  }, [summary, sentiment, followup, emailData.includeSummary, emailData.includeConclusion, emailData.includeActionPoints, isCustomMode, customBody, emailData.title]);

  // AI email generation function
  const generateAIEmail = async (): Promise<{ subject: string; body: string }> => {
    // Security helpers and token manager
    const { validateAndSanitizeForAI, rateLimiter } = await import('../utils/security');
    const { tokenManager } = await import('../utils/tokenManager');

    // Rate limit: max 10 email generations per minute
    const sessionId = 'email_generation_session';
    if (!rateLimiter.isAllowed(sessionId, 10, 60_000)) {
      throw new Error(t('rateLimitExceeded', 'Rate limit exceeded'));
    }

    // Resolve API key from multiple possible env sources to be robust in Vite/Netlify setups
    const env: any = (typeof import.meta !== 'undefined' ? (import.meta as any).env : {}) || {};
    const apiKey = (
      env.VITE_GEMINI_API_KEY ||
      env.VITE_GOOGLE_CLOUD_API_KEY ||
      (process as any)?.env?.GEMINI_API_KEY ||
      (process as any)?.env?.REACT_APP_GEMINI_API_KEY ||
      env.GEMINI_API_KEY
    )?.toString().trim();
    if (!apiKey) {
      console.error(t('emailMissingApiKey'));
      throw new Error(t('missingApiKey', 'API sleutel ontbreekt. Configureer GEMINI_API_KEY in de omgeving.'));
    }

    // Build prompt using selections
    const languageCode = getGeminiCode(currentLanguage || 'nl');

    const toneMap: Record<string, string> = {
      formal: t('tone.formal', 'formeel'),
      friendly: t('tone.friendly', 'vriendelijk'),
      direct: t('tone.direct', 'direct'),
      persuasive: t('tone.persuasive', 'overtuigend'),
      empathetic: t('tone.empathetic', 'empathisch'),
      humorous: t('tone.humorous', 'humoristisch'),
      neutral: t('tone.neutral', 'neutraal')
    };

    const detailDescriptor: Record<EmailData['detailLevel'], string> = {
      'very-short': t('detail.veryShort', 'zeer kort (3-5 zinnen)'),
      'short': t('detail.short', 'kort (1 korte alinea of bullets)'),
      'medium': t('detail.medium', 'gemiddeld (2-4 alinea’s, beknopt)'),
      'extensive': t('detail.extensive', 'uitgebreid (grondig en volledig)')
    };

    const includeParts: string[] = [];
    if (emailData.includeSummary && summary) includeParts.push(t('summary', 'Samenvatting'));
    if (emailData.includeConclusion && sentiment?.conclusion) includeParts.push(t('conclusions', 'Conclusies'));
    if (emailData.includeActionPoints && followup) includeParts.push(t('actionPoints', 'Actiepunten'));

    // Reply intent mapping
    const intentOptions: { key: EmailData['replyIntent']; label: string; directive: string }[] = [
      { key: 'agree', label: t('replyIntent.agree', 'Mee eens'), directive: t('replyIntent.agree.desc', 'Bevestig volledige overeenstemming met de inhoud of het voorstel.') },
      { key: 'take_action', label: t('replyIntent.take_action', 'Ik ga ermee aan de slag'), directive: t('replyIntent.take_action.desc', 'Informeer dat de taak/het verzoek is ontvangen en wordt opgepakt; noem kort de eerstvolgende stap.') },
      { key: 'forward', label: t('replyIntent.forward', 'Zal forwarden'), directive: t('replyIntent.forward.desc', 'Geef aan dat je de e-mail doorstuurt naar een relevante collega of afdeling (optioneel: noem wie).') },
      { key: 'thanks_info', label: t('replyIntent.thanks_info', 'Bedankt voor de info'), directive: t('replyIntent.thanks_info.desc', 'Spreek waardering uit voor de verstrekte informatie of update.') },
      { key: 'clarify', label: t('replyIntent.clarify', 'Ik snap het niet / Toelichting graag'), directive: t('replyIntent.clarify.desc', 'Vraag om verdere verduidelijking of aanvullende details; stel concrete vragen.') },
      { key: 'propose_meeting', label: t('replyIntent.propose_meeting', 'Afspraak voorstellen'), directive: t('replyIntent.propose_meeting.desc', 'Stel een (online/fysieke) meeting voor met datum/tijd-opties en doel.') },
      { key: 'no_time', label: t('replyIntent.no_time', 'Ik heb hier geen tijd voor'), directive: t('replyIntent.no_time.desc', 'Wijs beleefd af wegens tijdgebrek; bied indien mogelijk alternatief of planning.') },
      { key: 'request_more_details', label: t('replyIntent.request_more_details', 'Verzoek om meer details'), directive: t('replyIntent.request_more_details.desc', 'Vraag om concrete aanvullende informatie om te kunnen reageren of handelen.') },
      { key: 'disagree', label: t('replyIntent.disagree', 'Niet akkoord'), directive: t('replyIntent.disagree.desc', 'Geef beleefd aan dat je niet akkoord gaat en geef een korte onderbouwing.') },
      { key: 'ask_deadline', label: t('replyIntent.ask_deadline', 'Vraag om deadline'), directive: t('replyIntent.ask_deadline.desc', 'Vraag om een specifieke deadline of tijdlijn.') },
      { key: 'progress_update', label: t('replyIntent.progress_update', 'Update over voortgang'), directive: t('replyIntent.progress_update.desc', 'Geef een korte statusupdate en benoem volgende stappen.') },
      { key: 'suggestion', label: t('replyIntent.suggestion', 'Suggestie doen'), directive: t('replyIntent.suggestion.desc', 'Doe een constructieve suggestie of alternatief.') },
      { key: 'acknowledge_receipt', label: t('replyIntent.acknowledge_receipt', 'Bevestig ontvangst'), directive: t('replyIntent.acknowledge_receipt.desc', 'Laat weten dat de e-mail is ontvangen.') },
      { key: 'apologize', label: t('replyIntent.apologize', 'Excuses aanbieden'), directive: t('replyIntent.apologize.desc', 'Bied excuses aan voor fout/vertraging/misverstand en neem verantwoordelijkheid.') },
      { key: 'ask_feedback', label: t('replyIntent.ask_feedback', 'Feedback vragen'), directive: t('replyIntent.ask_feedback.desc', 'Vraag om feedback op een document, idee of actie.') },
      { key: 'reminder', label: t('replyIntent.reminder', 'Herinnering sturen'), directive: t('replyIntent.reminder.desc', 'Stuur een beleefde herinnering m.b.t. openstaande actie of deadline.') },
      { key: 'thank_followup', label: t('replyIntent.thank_followup', 'Dank voor de follow-up'), directive: t('replyIntent.thank_followup.desc', 'Spreek waardering uit voor het vervolgbericht en ga in op het vervolg.') },
      { key: 'out_of_office', label: t('replyIntent.out_of_office', 'Ik ben afwezig'), directive: t('replyIntent.out_of_office.desc', 'Informeer over tijdelijke afwezigheid met periode en (eventuele) vervanger.') },
      { key: 'not_right_person', label: t('replyIntent.not_right_person', 'Ik ben niet de juiste persoon'), directive: t('replyIntent.not_right_person.desc', 'Geef aan dat je niet de juiste contactpersoon bent en verwijs door indien mogelijk.') },
      { key: 'request_quote', label: t('replyIntent.request_quote', 'Offerte aanvragen'), directive: t('replyIntent.request_quote.desc', 'Vraag om een offerte voor het genoemde product of de dienst.') },
      { key: 'request_contact_details', label: t('replyIntent.request_contact_details', 'Contactgegevens vragen'), directive: t('replyIntent.request_contact_details.desc', 'Vraag om specifieke contactgegevens (telefoon, e-mail).') },
      { key: 'request_reference', label: t('replyIntent.request_reference', 'Referentie/bron vragen'), directive: t('replyIntent.request_reference.desc', 'Vraag om de bron of referentie van de genoemde informatie.') },
      { key: 'confidential', label: t('replyIntent.confidential', 'Dit is vertrouwelijk'), directive: t('replyIntent.confidential.desc', 'Herinner aan de vertrouwelijke aard van de inhoud.') },
      { key: 'call_me', label: t('replyIntent.call_me', 'Bel me hierover'), directive: t('replyIntent.call_me.desc', 'Vraag om telefonisch contact en geef je beschikbaarheid aan.') },
      { key: 'no_action_required', label: t('replyIntent.no_action_required', 'Geen actie vereist'), directive: t('replyIntent.no_action_required.desc', 'Informeer dat er geen verdere actie nodig is.') },
    ];

    const selectedIntent = intentOptions.find(o => o.key === emailData.replyIntent) || intentOptions[0];
    // Add safe labels to avoid referencing undefined option variables
    const toneLabel = toneMap[emailData.tone] || t('tone.neutral', 'neutraal');
    const narrativeLabel = emailData.narrative ? t('narrativeStory', 'Verhalend/storytelling') : t('narrativeNeutral', 'Neutraal');
    const intentLabel = selectedIntent.label;
    const detailLabel = detailDescriptor[emailData.detailLevel];
    
    const instructionRaw = `Maak een complete e-mail in het ${languageCode}.
    - Doel: stuur een follow-up e-mail na een meeting/webinar.
    - Titel: "${(emailData.title || '').trim()}" (gebruik dit uitsluitend als onderwerp van de e-mail).
    - Toon: ${toneMap[emailData.tone] || 'neutraal'}.
    - Stijl: ${emailData.narrative ? 'verhalend/storytelling (vloeiende overgang, context schetsen)' : 'zakelijk en to-the-point'}.
    - Reactie-intentie: ${selectedIntent.label} — ${selectedIntent.directive}.
    - Detailniveau: ${detailDescriptor[emailData.detailLevel]}.
    - Secties die zeker moeten terugkomen: ${includeParts.length > 0 ? includeParts.join(', ') : t('emailSectionsNone', 'gebruik je eigen samenvattende structuur')}.
    - Formaat: platte tekst (GEEN HTML, GEEN Markdown, GEEN codeblokken).
    - Output: geef ALLEEN de e-mailtekst (zonder metadata).
    
    Context:
    - Toon: "${toneLabel}"
    - Narratief: "${narrativeLabel}"
    - Intentie: "${intentLabel}"
    - Detailniveau: "${detailLabel}"
    - Opnemen: ${includeParts.length > 0 ? includeParts.join(', ') : t('none', 'Geen')}
    
    Belangrijk:
    - Gebruik "${(emailData.title || autoGeneratedSubject || '').trim()}" uitsluitend als onderwerp (subject) van de e-mail.
    - Laat de body beginnen met een passende aanhef en herhaal de titel NIET bovenaan de body.
    - Gebruik platte tekst zonder HTML of Markdown.
    - Houd rekening met de selectie van Samenvatting/Conclusies/Actiepunten zoals aangegeven.
    - Schrijf beknopt, warm en professioneel.`;

    const transcriptSnippet = (transcript || '').slice(0, 12_000); // keep prompt size reasonable
    const summarySanitized = validateAndSanitizeForAI(summary || '', 50_000).sanitized;
    const sentimentConclusion = validateAndSanitizeForAI(sentiment?.conclusion || '', 20_000).sanitized;
    const followupSanitized = validateAndSanitizeForAI(followup || '', 20_000).sanitized;

    const fullPrompt = `Context voor de e-mail:
    --- TRANSCRIPT (ingekort) ---\n${transcriptSnippet}\n--- EINDE TRANSCRIPT ---
    
    --- SAMENVATTING ---\n${summarySanitized}\n--- EINDE SAMENVATTING ---
    
    --- CONCLUSIE ---\n${sentimentConclusion}\n--- EINDE CONCLUSIE ---
    
    --- ACTIEPUNTEN ---\n${followupSanitized}\n--- EINDE ACTIEPUNTEN ---
    
    OPDRACHT:\n${instructionRaw}\n\nGeef je antwoord uitsluiten in het volgende JSON-formaat:\n{ "subject": string, "body": string }`;

    // Validate token usage before API call
    const tokenEstimate = tokenManager.estimateTokens(fullPrompt, 2);
    const tokenValidation = await tokenManager.validateTokenUsage(userId, userTier, tokenEstimate.totalTokens);
    
    if (!tokenValidation.allowed) {
      throw new Error(tokenValidation.reason || 'Token limiet bereikt. Upgrade je abonnement voor meer AI-generaties.');
    }
    
    const ai = new GoogleGenAI({ apiKey });
    const modelName = await modelManager.getModelForUser(userId, userTier, 'emailComposition');
    const response = await ai.models.generateContent({ 
      model: modelName, 
      contents: fullPrompt,
      config: { responseMimeType: 'application/json', responseSchema: { type: 'object', properties: { subject: { type: 'string' }, body: { type: 'string' } }, required: ['subject', 'body'] } }
    });

    let subject = '';
    let body = '';
    try {
      const json = JSON.parse((response as any).text);
      subject = (json.subject || '').toString();
      body = (json.body || '').toString();
    } catch (e) {
      const raw = (((response as any).text || '') as string).trim();
      const subjMatch = raw.match(/subject\s*:\s*(.*)/i);
      const bodyMatch = raw.match(/body\s*:\s*([\s\S]*)/i);
      subject = subjMatch ? subjMatch[1].trim() : generateAutoSubject(summary || transcript);
      body = bodyMatch ? bodyMatch[1].trim() : buildEmailBody();
    }

    // Post-process: ensure format matches selection
    // Always plain text
    body = body.replace(/<[^>]+>/g, '');
    // Do NOT inject title into body; body should start with salutation or AI-generated content
    const subj = (emailData.title || subject || '').trim();
    // Previously, the title was prefixed to the body to ensure it appeared at the top.
    // This behavior is now disabled to avoid duplication of the subject/title in the email body.
    // if (subj && !body.startsWith(subj)) {
    //   body = `${subj}\n\n${body}`;
    // }

    // Record token usage
    const { tokenCounter } = await import('../tokenCounter');
    const promptTokens = tokenCounter.countPromptTokens(fullPrompt);
    const responseTokens = tokenCounter.countResponseTokens((response as any).text || '');
    
    try {
      await tokenManager.recordTokenUsage(userId, promptTokens, responseTokens);
    } catch (error) {
      console.error('Error recording token usage:', error);
    }

    return { subject: subj || subject, body };
  };

  // Update email data when custom mode changes
  useEffect(() => {
    if (isCustomMode) {
      setEmailData(prev => ({
        ...prev,
        subject: customSubject,
        body: customBody
      }));
    } else if (autoGeneratedSubject) {
      setEmailData(prev => ({
        ...prev,
        subject: autoGeneratedSubject,
        body: buildEmailBody()
      }));
    }
  }, [customSubject, customBody, isCustomMode, autoGeneratedSubject]);

  const handleAddressChange = (type: 'to' | 'cc' | 'bcc', addresses: string[]) => {
    setEmailData(prev => ({
      ...prev,
      [type]: addresses
    }));
  };



  // Update email data from selections
  const updateEmailDataFromSelections = (emails: ExtractedEmail[]) => {
    const newEmailData = { to: [], cc: [], bcc: [] } as { to: string[]; cc: string[]; bcc: string[] };
    
    emails.forEach((extractedEmail) => {
      if (extractedEmail.type !== 'none' && !newEmailData[extractedEmail.type].includes(extractedEmail.email)) {
        newEmailData[extractedEmail.type].push(extractedEmail.email);
      }
    });

    setEmailData(prev => ({ ...prev, ...newEmailData }));
  };

  // Handle extracted email type change
  const handleExtractedEmailTypeChange = (index: number, type: 'to' | 'cc' | 'bcc' | 'none') => {
    const updatedEmails = [...extractedEmails];
    updatedEmails[index].type = type;
    setExtractedEmails(updatedEmails);
    
    // Update email data based on selections
    updateEmailDataFromSelections(updatedEmails);
  };

  // Bulk set all extracted emails to same type
  const handleBulkEmailTypeChange = (type: 'to' | 'cc' | 'bcc' | 'none') => {
    const updatedEmails = extractedEmails.map(email => ({ ...email, type }));
    setExtractedEmails(updatedEmails);
    
    // Update email data based on selections
    updateEmailDataFromSelections(updatedEmails);
  };

  const copyToClipboard = async (text: string) => {
    try {
      await navigator.clipboard.writeText(text);
      displayToast(t('copiedToClipboard', 'Gekopieerd naar klembord!'), 'success');
    } catch (err) {
      console.error('Failed to copy to clipboard:', err);
      displayToast(t('copyFailed', 'Kopiëren mislukt'), 'error');
    }
  };

  // Modal states
  const [showPreviewModal, setShowPreviewModal] = useState(false);
  const [showMailtoModal, setShowMailtoModal] = useState(false);
  const [isGenerating, setIsGenerating] = useState<boolean>(false);

  // Handle preview
  const handlePreview = () => {
    ensureGeneratedThen('preview');
  };

  // Copy email body to clipboard
  const copyEmailBodyToClipboard = () => {
    navigator.clipboard.writeText(emailData.body).then(() => {
      displayToast(t('copiedToClipboard', 'Gekopieerd naar klembord!'), 'success');
    }).catch(err => {
      console.error('Failed to copy email body: ', err);
      displayToast(t('copyFailed', 'Kopiëren mislukt'), 'error');
    });
  };

  // Get selected emails by type
  const getSelectedEmails = (type: 'to' | 'cc' | 'bcc') => {
    return extractedEmails.filter(email => email.type === type).map(email => email.email);
  };

  const handleMailto = () => {
    setShowMailtoModal(true);
  };

  // Generate mailto URL
  const generateMailtoUrl = () => {
    const toEmails = getSelectedEmails('to');
    const ccEmails = getSelectedEmails('cc');
    const bccEmails = getSelectedEmails('bcc');
    const to = toEmails.join(',');
    const params: string[] = [];
    if (ccEmails.length > 0) params.push('cc=' + encodeURIComponent(ccEmails.join(',')));
    if (bccEmails.length > 0) params.push('bcc=' + encodeURIComponent(bccEmails.join(',')));
    if (emailData.subject) params.push('subject=' + encodeURIComponent((emailData.subject || '').replace(/\*\*|__|[_*`~]/g, '').trim()));
    if (emailData.body) {
      const normalizedBody = (emailData.body || '').replace(/\r?\n/g, '\r\n');
      params.push('body=' + encodeURIComponent(normalizedBody));
    }
    const query = params.length ? ('?' + params.join('&')) : '';
    return `mailto:${to}${query}`;
  };

  // Ensure generated before action
  const ensureGeneratedThen = async (action: 'preview' | 'mailto') => {
    // enforce plain text always
    if (emailData.format !== 'plain') {
      setEmailData(prev => ({ ...prev, format: 'plain' }));
    }

    if (!aiHasGenerated) {
      setIsGenerating(true);
      try {
        const result = await generateAIEmail();
        setEmailData(prev => ({
          ...prev,
          subject: prev.title && prev.title.trim().length > 0 ? prev.title : result.subject,
          body: result.body,
          format: 'plain'
        }));
        setAiHasGenerated(true);
      } catch (e) {
        console.error('AI generation failed', e);
      } finally {
        setIsGenerating(false);
      }
    }

    if (action === 'preview') {
      onPreviewEmail?.(emailData);
      setShowPreviewModal(true);
    } else {
      onOpenMailto?.(emailData);
    }
  };

  // Copy email content to clipboard
  const copyFullEmailToClipboard = () => {
    const toEmails = getSelectedEmails('to');
    const ccEmails = getSelectedEmails('cc');
    const bccEmails = getSelectedEmails('bcc');
    
    let emailContent = '';
    if (toEmails.length > 0) emailContent += `To: ${toEmails.join(', ')}\n`;
    if (ccEmails.length > 0) emailContent += `CC: ${ccEmails.join(', ')}\n`;
    if (bccEmails.length > 0) emailContent += `BCC: ${bccEmails.join(', ')}\n`;
    if (emailData.subject) emailContent += `Subject: ${emailData.subject}\n\n`;
    if (emailData.body) emailContent += emailData.body;
    
    navigator.clipboard.writeText(emailContent).then(() => {
      displayToast(t('copiedToClipboard', 'Gekopieerd naar klembord!'), 'success');
    }).catch(err => {
      console.error('Failed to copy full email: ', err);
      displayToast(t('copyFailed', 'Kopiëren mislukt'), 'error');
    });
  };

  const handleGenerateAIEmail = async () => {
    setIsGenerating(true);
    try {
      const result = await generateAIEmail();
      setEmailData(prev => ({
        ...prev,
        subject: result.subject,
        body: result.body
      }));
    } catch (error) {
      console.error(t('emailGenerationError'), error);
      // TODO: Show error message to user
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* Email Address Selection */}
      {extractedEmails.length > 0 && (
        <div className="bg-blue-50 dark:bg-slate-800 rounded-lg border border-blue-200 dark:border-slate-700 p-4">
          <h3 className="text-lg font-medium text-blue-800 dark:text-slate-200 mb-4 flex items-center">
            <div className="mr-2 text-blue-600"><FiMail size={20} /></div>
            {t('emailComposition.emailSelection', 'Email Adres Selectie')}
          </h3>
          <p className="text-sm text-blue-700 dark:text-slate-300 mb-4">
            {t('emailComposition.emailSelectionDescription', 'Selecteer voor elk geëxtraheerd email adres of het gebruikt moet worden als To, CC, BCC of niet gebruikt (N/A).')}
          </p>
          <div className="space-y-3">
            {extractedEmails.map((extractedEmail, index) => (
              <div key={index} className="flex items-center justify-between p-4 bg-white dark:bg-slate-700 rounded-lg border border-blue-200 dark:border-slate-600 shadow-sm">
                <div className="flex items-center flex-1">
                  <div className="w-3 h-3 bg-blue-500 rounded-full mr-3"></div>
                  <span className="text-sm font-medium text-gray-800 dark:text-slate-200 font-mono">{extractedEmail.email}</span>
                </div>
                <div className="flex items-center space-x-2">
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name={`email-${index}`}
                      value="to"
                      checked={extractedEmail.type === 'to'}
                      onChange={(e) => handleExtractedEmailTypeChange(index, e.target.value as 'to' | 'cc' | 'bcc' | 'none')}
                      className="mr-1 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="text-sm text-gray-700 dark:text-slate-300">{t('emailTo', 'To')}</span>
                  </label>
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name={`email-${index}`}
                      value="cc"
                      checked={extractedEmail.type === 'cc'}
                      onChange={(e) => handleExtractedEmailTypeChange(index, e.target.value as 'to' | 'cc' | 'bcc' | 'none')}
                      className="mr-1 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="text-sm text-gray-700 dark:text-slate-300">{t('emailCC', 'CC')}</span>
                  </label>
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name={`email-${index}`}
                      value="bcc"
                      checked={extractedEmail.type === 'bcc'}
                      onChange={(e) => handleExtractedEmailTypeChange(index, e.target.value as 'to' | 'cc' | 'bcc' | 'none')}
                      className="mr-1 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="text-sm text-gray-700 dark:text-slate-300">{t('emailBCC', 'BCC')}</span>
                  </label>
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name={`email-${index}`}
                      value="none"
                      checked={extractedEmail.type === 'none'}
                      onChange={(e) => handleExtractedEmailTypeChange(index, e.target.value as 'to' | 'cc' | 'bcc' | 'none')}
                      className="mr-1 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="text-sm text-gray-700 dark:text-slate-300">{t('emailNA', 'N/A')}</span>
                  </label>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}



      {/* Email Management - hidden as per request */}
      {false && (
        <div className="bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-gray-200 dark:border-slate-700 p-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4 flex items-center">
            <div className="mr-2"><FiUsers size={20} /></div>
            {t('emailComposition.recipientsTitle', 'Email Beheer')}
          </h3>
          {/* ... existing code ... */}
        </div>
      )}

      {/* Email Customization Options */}
      <div className="bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-gray-200 dark:border-slate-700 p-6">
        {/* Tone of voice */}
        <div className="mb-6">
          <h4 className="text-md font-medium text-gray-800 dark:text-slate-200 mb-3">{t('toneOfVoice', 'Toon van de e-mail')}</h4>
          <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-3 text-gray-800 dark:text-slate-200">
            {([
              { key: 'formal', label: t('tone.formal', 'Formeel') },
              { key: 'friendly', label: t('tone.friendly', 'Vriendelijk') },
              { key: 'direct', label: t('tone.direct', 'Direct') },
              { key: 'persuasive', label: t('tone.persuasive', 'Overtuigend') },
              { key: 'empathetic', label: t('tone.empathetic', 'Empathisch') },
              { key: 'humorous', label: t('tone.humorous', 'Humoristisch') },
              { key: 'neutral', label: t('tone.neutral', 'Neutraal') },
            ] as {key: string; label: string}[]).map(opt => (
              <label key={opt.key} className="flex items-center p-3 rounded border border-gray-200 dark:border-slate-600 hover:bg-gray-50 dark:hover:bg-slate-700 cursor-pointer bg-gray-50 dark:bg-slate-700">
                <input
                  type="radio"
                  name="email-tone"
                  value={opt.key}
                  checked={emailData.tone === opt.key}
                  onChange={(e) => { setEmailData(prev => ({ ...prev, tone: e.target.value })); setAiHasGenerated(false); }}
                  className="mr-2"
                />
                <span>{opt.label}</span>
              </label>
            ))}
          </div>
        </div>

        {/* Narrative toggle */}
        <div className="mb-6">
          <h4 className="text-md font-medium text-gray-800 dark:text-slate-200 mb-2">{t('narrativeStyle', 'Verhalende stijl')}</h4>
          <label className="flex items-center text-gray-800 dark:text-slate-200 cursor-pointer bg-gray-50 dark:bg-slate-700 p-3 rounded border border-gray-200 dark:border-slate-600 hover:bg-gray-100 dark:hover:bg-slate-600">
            <input
              type="checkbox"
              checked={emailData.narrative}
              onChange={(e) => { setEmailData(prev => ({ ...prev, narrative: e.target.checked })); setAiHasGenerated(false); }}
              className="mr-2"
            />
            <span className="text-sm">{t('narrativeDesc', 'Maak de e-mail meer storytelling en minder zakelijk')}</span>
          </label>
        </div>

        {/* Nieuw: Primaire reactie/actie (reply intent) */}
        <div className="mb-6">
          <h4 className="text-md font-medium text-gray-800 dark:text-slate-200 mb-2">{t('emailComposition.replyIntentQuestion', 'Wat is je primaire reactie of actie met betrekking tot deze e-mail?')}</h4>
          <div className="grid sm:grid-cols-2 gap-3 text-gray-800 dark:text-slate-200">
            {([
              { key: 'agree', label: t('replyIntent.agree', 'Mee eens'), directive: t('replyIntent.agree.desc', 'Bevestig volledige overeenstemming met de inhoud of het voorstel.') },
              { key: 'take_action', label: t('replyIntent.take_action', 'Ik ga ermee aan de slag'), directive: t('replyIntent.take_action.desc', 'Informeer dat de taak/het verzoek is ontvangen en wordt opgepakt; noem kort de eerstvolgende stap.') },
              { key: 'forward', label: t('replyIntent.forward', 'Zal forwarden'), directive: t('replyIntent.forward.desc', 'Geef aan dat je de e-mail doorstuurt naar een relevante collega of afdeling (optioneel: noem wie).') },
              { key: 'thanks_info', label: t('replyIntent.thanks_info', 'Bedankt voor de info'), directive: t('replyIntent.thanks_info.desc', 'Spreek waardering uit voor de verstrekte informatie of update.') },
              { key: 'clarify', label: t('replyIntent.clarify', 'Ik snap het niet / Toelichting graag'), directive: t('replyIntent.clarify.desc', 'Vraag om verdere verduidelijking of aanvullende details; stel concrete vragen.') },
              { key: 'propose_meeting', label: t('replyIntent.propose_meeting', 'Afspraak voorstellen'), directive: t('replyIntent.propose_meeting.desc', 'Stel een (online/fysieke) meeting voor met datum/tijd-opties en doel.') },
              { key: 'no_time', label: t('replyIntent.no_time', 'Ik heb hier geen tijd voor'), directive: t('replyIntent.no_time.desc', 'Wijs beleefd af wegens tijdgebrek; bied indien mogelijk alternatief of planning.') },
              { key: 'request_more_details', label: t('replyIntent.request_more_details', 'Verzoek om meer details'), directive: t('replyIntent.request_more_details.desc', 'Vraag om concrete aanvullende informatie om te kunnen reageren of handelen.') },
              { key: 'disagree', label: t('replyIntent.disagree', 'Niet akkoord'), directive: t('replyIntent.disagree.desc', 'Geef beleefd aan dat je niet akkoord gaat en geef een korte onderbouwing.') },
              { key: 'ask_deadline', label: t('replyIntent.ask_deadline', 'Vraag om deadline'), directive: t('replyIntent.ask_deadline.desc', 'Vraag om een specifieke deadline of tijdlijn.') },
              { key: 'progress_update', label: t('replyIntent.progress_update', 'Update over voortgang'), directive: t('replyIntent.progress_update.desc', 'Geef een korte statusupdate en benoem volgende stappen.') },
              { key: 'suggestion', label: t('replyIntent.suggestion', 'Suggestie doen'), directive: t('replyIntent.suggestion.desc', 'Doe een constructieve suggestie of alternatief.') },
              { key: 'acknowledge_receipt', label: t('replyIntent.acknowledge_receipt', 'Bevestig ontvangst'), directive: t('replyIntent.acknowledge_receipt.desc', 'Laat weten dat de e-mail is ontvangen.') },
              { key: 'apologize', label: t('replyIntent.apologize', 'Excuses aanbieden'), directive: t('replyIntent.apologize.desc', 'Bied excuses aan voor fout/vertraging/misverstand en neem verantwoordelijkheid.') },
              { key: 'ask_feedback', label: t('replyIntent.ask_feedback', 'Feedback vragen'), directive: t('replyIntent.ask_feedback.desc', 'Vraag om feedback op een document, idee of actie.') },
              { key: 'reminder', label: t('replyIntent.reminder', 'Herinnering sturen'), directive: t('replyIntent.reminder.desc', 'Stuur een beleefde herinnering m.b.t. openstaande actie of deadline.') },
              { key: 'thank_followup', label: t('replyIntent.thank_followup', 'Dank voor de follow-up'), directive: t('replyIntent.thank_followup.desc', 'Spreek waardering uit voor het vervolgbericht en ga in op het vervolg.') },
              { key: 'out_of_office', label: t('replyIntent.out_of_office', 'Ik ben afwezig'), directive: t('replyIntent.out_of_office.desc', 'Informeer over tijdelijke afwezigheid met periode en (eventuele) vervanger.') },
              { key: 'not_right_person', label: t('replyIntent.not_right_person', 'Ik ben niet de juiste persoon'), directive: t('replyIntent.not_right_person.desc', 'Geef aan dat je niet de juiste contactpersoon bent en verwijs door indien mogelijk.') },
              { key: 'request_quote', label: t('replyIntent.request_quote', 'Offerte aanvragen'), directive: t('replyIntent.request_quote.desc', 'Vraag om een offerte voor het genoemde product of de dienst.') },
              { key: 'request_contact_details', label: t('replyIntent.request_contact_details', 'Contactgegevens vragen'), directive: t('replyIntent.request_contact_details.desc', 'Vraag om specifieke contactgegevens (telefoon, e-mail).') },
              { key: 'request_reference', label: t('replyIntent.request_reference', 'Referentie/bron vragen'), directive: t('replyIntent.request_reference.desc', 'Vraag om de bron of referentie van de genoemde informatie.') },
              { key: 'confidential', label: t('replyIntent.confidential', 'Dit is vertrouwelijk'), directive: t('replyIntent.confidential.desc', 'Herinner aan de vertrouwelijke aard van de inhoud.') },
              { key: 'call_me', label: t('replyIntent.call_me', 'Bel me hierover'), directive: t('replyIntent.call_me.desc', 'Vraag om telefonisch contact en geef je beschikbaarheid aan.') },
              { key: 'no_action_required', label: t('replyIntent.no_action_required', 'Geen actie vereist'), directive: t('replyIntent.no_action_required.desc', 'Informeer dat er geen verdere actie nodig is.') },
            ] as { key: string; label: string; directive: string }[]).map(opt => (
              <label key={opt.key} className="flex items-start p-3 rounded border border-gray-200 dark:border-slate-600 hover:bg-gray-50 dark:hover:bg-slate-700 cursor-pointer bg-gray-50 dark:bg-slate-700">
                <input
                  type="radio"
                  name="reply-intent"
                  value={opt.key}
                  checked={emailData.replyIntent === opt.key}
                  onChange={(e) => { setEmailData(prev => ({ ...prev, replyIntent: e.target.value })); setAiHasGenerated(false); }}
                  className="mr-2 mt-1"
                />
                <span>
                  <div className="font-medium text-gray-800 dark:text-slate-200">{opt.label}</div>
                  <div className="text-xs text-gray-600 dark:text-slate-400">{opt.directive}</div>
                </span>
              </label>
            ))}
          </div>
        </div>

        {/* Detail level */}
        <div className="mb-6">
          <h4 className="text-md font-medium text-gray-800 dark:text-slate-200 mb-3">{t('detailLevel', 'Detailniveau')}</h4>
          <div className="grid sm:grid-cols-2 gap-3 text-gray-800">
            {([
              { key: 'very-short', label: t('detail.veryShort', 'Zeer kort'), desc: t('detail.veryShortDesc', '3-5 zinnen, direct to the point') },
              { key: 'short', label: t('detail.short', 'Kort'), desc: t('detail.shortDesc', 'Korte alinea of bullets') },
              { key: 'medium', label: t('detail.medium', 'Gemiddeld'), desc: t('detail.mediumDesc', '2-4 alinea’s, kernachtig') },
              { key: 'extensive', label: t('detail.extensive', 'Uitgebreid'), desc: t('detail.extensiveDesc', 'Volledige recap met details') },
            ] as {key: EmailData['detailLevel']; label: string; desc: string}[]).map(opt => (
              <label key={opt.key} className="flex items-start p-3 rounded border border-gray-200 dark:border-slate-600 hover:bg-gray-50 dark:hover:bg-slate-700 cursor-pointer bg-gray-50 dark:bg-slate-700">
                <input
                  type="radio"
                  name="detail-level"
                  value={opt.key}
                  checked={emailData.detailLevel === opt.key}
                  onChange={(e) => { setEmailData(prev => ({ ...prev, detailLevel: e.target.value as EmailData['detailLevel'] })); setAiHasGenerated(false); }}
                  className="mr-2 mt-1"
                />
                <span>
                  <div className="font-medium text-gray-800 dark:text-slate-200">{opt.label}</div>
                  <div className="text-xs text-gray-600 dark:text-slate-400">{opt.desc}</div>
                </span>
              </label>
            ))}
          </div>
        </div>

        {/* Include Options */}
        <div className="mb-4">
          <h4 className="text-md font-medium text-gray-800 dark:text-slate-200 mb-3">
            {t('emailIncludeOptions', 'Wat wil je opnemen in de e-mail?')}
          </h4>
          <div className="space-y-3">
            <label className="flex items-center cursor-pointer text-gray-800 dark:text-slate-200 bg-gray-50 dark:bg-slate-700 p-3 rounded border border-gray-200 dark:border-slate-600 hover:bg-gray-100 dark:hover:bg-slate-600">
              <input
                type="checkbox"
                checked={emailData.includeSummary}
                onChange={(e) => { setEmailData(prev => ({ ...prev, includeSummary: e.target.checked })); setAiHasGenerated(false); }}
                className="mr-3"
              />
              <span className="text-sm text-gray-800 dark:text-slate-200">{t('includeSummary', 'Samenvatting toevoegen')}</span>
            </label>
            <label className="flex items-center cursor-pointer text-gray-800 dark:text-slate-200 bg-gray-50 dark:bg-slate-700 p-3 rounded border border-gray-200 dark:border-slate-600 hover:bg-gray-100 dark:hover:bg-slate-600">
              <input
                type="checkbox"
                checked={emailData.includeConclusion}
                onChange={(e) => { setEmailData(prev => ({ ...prev, includeConclusion: e.target.checked })); setAiHasGenerated(false); }}
                className="mr-3"
              />
              <span className="text-sm text-gray-800 dark:text-slate-200">{t('includeConclusions', 'Conclusies toevoegen')}</span>
            </label>
            <label className="flex items-center cursor-pointer text-gray-800 dark:text-slate-200 bg-gray-50 dark:bg-slate-700 p-3 rounded border border-gray-200 dark:border-slate-600 hover:bg-gray-100 dark:hover:bg-slate-600">
              <input
                type="checkbox"
                checked={emailData.includeActionPoints}
                onChange={(e) => { setEmailData(prev => ({ ...prev, includeActionPoints: e.target.checked })); setAiHasGenerated(false); }}
                className="mr-3"
              />
              <span className="text-sm text-gray-800 dark:text-slate-200">{t('includeActionPoints', 'Actiepunten toevoegen')}</span>
            </label>

            {/* Title field */}
            <div className="mt-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-slate-300 mb-1">
                {t('emailTitle', 'Titel')}
              </label>
              <input
                type="text"
                value={emailData.title}
                onChange={(e) => { const val = e.target.value.replace(/\*\*|__|[_*`~]/g, '').trim(); setEmailData(prev => ({ ...prev, title: val, subject: val })); setAiHasGenerated(false); }}
                placeholder={t('emailTitlePlaceholder', 'Titel van de e-mail')}
                className="w-full border border-gray-300 dark:border-slate-700 rounded-md p-2 text-gray-800 dark:text-slate-200 bg-white dark:bg-slate-800"
              />
              <p className="text-xs text-gray-500 dark:text-slate-400 mt-1">{t('emailTitleHelp', 'Wordt gebruikt als onderwerp van de e-mail. De body start met een aanhef. Je kunt dit aanpassen.')}</p>
            </div>
          </div>
        </div>
      </div>

      {/* Email Content */}
      <div className="bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-gray-200 dark:border-slate-700 p-6">
        {/* Email content will be displayed here */}
      </div>

      {/* Bottom Actions */}
      <div className="flex items-center gap-3">
        <button onClick={handlePreview} disabled={isGenerating} className="inline-flex items-center gap-2 px-4 py-2 rounded-md bg-blue-600 hover:bg-blue-700 disabled:bg-blue-400 text-white">
          <span className="w-4 h-4 inline-flex items-center justify-center"><FiEye size={16} /></span>
          {t('emailPreview')}
        </button>
        <button onClick={() => ensureGeneratedThen('mailto')} disabled={isGenerating} className="inline-flex items-center gap-2 px-4 py-2 rounded-md bg-green-600 hover:bg-green-700 disabled:bg-green-400 text-white">
          <span className="w-4 h-4 inline-flex items-center justify-center"><FiSend size={16} /></span>
          {t('openInEmailClient')}
        </button>
      </div>

      {/* Preview Modal */}
      <EmailPreviewModal
        isOpen={showPreviewModal}
        onClose={() => setShowPreviewModal(false)}
        emailSubject={emailData.subject}
        emailAddresses={extractedEmails.map(e => ({ address: e.email, type: (e.type === 'none' ? 'na' : e.type) as 'to' | 'cc' | 'bcc' | 'na' }))}
        emailContent={emailData.body}
        t={t}
      />

      {/* Loading Overlay */}
      {isGenerating && (
        <BlurredLoadingOverlay text={t('generatingEmail', 'E-mail genereren...')} />
      )}
    </div>
  );
}

export default EmailCompositionTab;